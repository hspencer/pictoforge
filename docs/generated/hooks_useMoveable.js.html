<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: hooks/useMoveable.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: hooks/useMoveable.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { useCallback, useRef, useState } from 'react';

/**
 * Hook para integrar Moveable con transformaciones SVG
 * Maneja los eventos de drag, resize y rotate usando el CoordinateTransformer
 *
 * @param {Object} options - Opciones de configuraci贸n
 * @param {Object} options.coordinateTransformer - Instancia del CoordinateTransformer
 * @param {Function} options.onTransformStart - Callback al iniciar transformaci贸n
 * @param {Function} options.onTransform - Callback durante transformaci贸n
 * @param {Function} options.onTransformEnd - Callback al finalizar transformaci贸n
 * @returns {Object} Handlers y estado para Moveable
 */
export function useMoveable({
  coordinateTransformer,
  onTransformStart,
  onTransform,
  onTransformEnd,
} = {}) {
  const [isDragging, setIsDragging] = useState(false);
  const [isResizing, setIsResizing] = useState(false);
  const [isRotating, setIsRotating] = useState(false);
  const initialTransformRef = useRef(null);

  /**
   * Extrae valores actuales de transform de un elemento
   */
  const getElementTransform = useCallback((element) => {
    const transform = element.getAttribute('transform') || '';
    const result = {
      translateX: 0,
      translateY: 0,
      scaleX: 1,
      scaleY: 1,
      rotation: 0,
      raw: transform,
    };

    // Parse translate
    const translateMatch = transform.match(/translate\(([^,]+),\s*([^)]+)\)/);
    if (translateMatch) {
      result.translateX = parseFloat(translateMatch[1]) || 0;
      result.translateY = parseFloat(translateMatch[2]) || 0;
    }

    // Parse scale
    const scaleMatch = transform.match(/scale\(([^,]+)(?:,\s*([^)]+))?\)/);
    if (scaleMatch) {
      result.scaleX = parseFloat(scaleMatch[1]) || 1;
      result.scaleY = parseFloat(scaleMatch[2] || scaleMatch[1]) || 1;
    }

    // Parse rotate
    const rotateMatch = transform.match(/rotate\(([^)]+)\)/);
    if (rotateMatch) {
      result.rotation = parseFloat(rotateMatch[1]) || 0;
    }

    return result;
  }, []);

  /**
   * Construye string de transform desde valores individuales
   */
  const buildTransformString = useCallback((transforms) => {
    const parts = [];

    if (transforms.translateX !== 0 || transforms.translateY !== 0) {
      parts.push(`translate(${transforms.translateX}, ${transforms.translateY})`);
    }

    if (transforms.rotation !== 0) {
      parts.push(`rotate(${transforms.rotation})`);
    }

    if (transforms.scaleX !== 1 || transforms.scaleY !== 1) {
      parts.push(`scale(${transforms.scaleX}, ${transforms.scaleY})`);
    }

    return parts.join(' ');
  }, []);

  /**
   * Handler de inicio de arrastre
   */
  const handleDragStart = useCallback((e) => {
    setIsDragging(true);
    const element = e.target;
    initialTransformRef.current = getElementTransform(element);

    if (onTransformStart) {
      onTransformStart({ type: 'drag', element, event: e });
    }

    console.log(' Drag Start:', {
      element: element.id,
      initialTransform: initialTransformRef.current,
    });
  }, [getElementTransform, onTransformStart]);

  /**
   * Handler de arrastre
   */
  const handleDrag = useCallback((e) => {
    const element = e.target;
    const initial = initialTransformRef.current;

    if (!initial) return;

    // Convertir delta de pantalla a delta SVG
    let deltaX = e.beforeTranslate[0];
    let deltaY = e.beforeTranslate[1];

    // Si tenemos coordinateTransformer, convertir delta
    if (coordinateTransformer?.screenDeltaToSvgDelta) {
      const svgDelta = coordinateTransformer.screenDeltaToSvgDelta(deltaX, deltaY);
      deltaX = svgDelta.dx;
      deltaY = svgDelta.dy;
    }

    // Aplicar transformaci贸n
    const newTransform = {
      ...initial,
      translateX: initial.translateX + deltaX,
      translateY: initial.translateY + deltaY,
    };

    const transformString = buildTransformString(newTransform);
    element.setAttribute('transform', transformString);

    // Actualizar la traducci贸n visual de Moveable
    e.target.style.transform = e.transform;

    if (onTransform) {
      onTransform({
        type: 'drag',
        element,
        transform: newTransform,
        event: e,
      });
    }

    console.log(' Drag:', {
      screenDelta: e.beforeTranslate,
      svgDelta: { deltaX, deltaY },
      newTransform,
    });
  }, [coordinateTransformer, buildTransformString, onTransform]);

  /**
   * Handler de fin de arrastre
   */
  const handleDragEnd = useCallback((e) => {
    setIsDragging(false);
    const element = e.target;

    // Limpiar el style.transform que Moveable aplic贸
    element.style.transform = '';

    if (onTransformEnd) {
      const finalTransform = getElementTransform(element);
      onTransformEnd({
        type: 'drag',
        element,
        transform: finalTransform,
        event: e,
      });
    }

    initialTransformRef.current = null;

    console.log(' Drag End:', {
      element: element.id,
      finalTransform: getElementTransform(element),
    });
  }, [getElementTransform, onTransformEnd]);

  /**
   * Handler de inicio de resize
   */
  const handleResizeStart = useCallback((e) => {
    setIsResizing(true);
    const element = e.target;
    initialTransformRef.current = getElementTransform(element);

    if (onTransformStart) {
      onTransformStart({ type: 'resize', element, event: e });
    }

    console.log(' Resize Start:', {
      element: element.id,
      initialTransform: initialTransformRef.current,
    });
  }, [getElementTransform, onTransformStart]);

  /**
   * Handler de resize
   */
  const handleResize = useCallback((e) => {
    const element = e.target;
    const initial = initialTransformRef.current;

    if (!initial) return;

    // Calcular nueva escala
    const scaleX = e.width / e.startWidth;
    const scaleY = e.height / e.startHeight;

    // Aplicar transformaci贸n
    const newTransform = {
      ...initial,
      scaleX: initial.scaleX * scaleX,
      scaleY: initial.scaleY * scaleY,
      translateX: initial.translateX + e.drag.beforeTranslate[0],
      translateY: initial.translateY + e.drag.beforeTranslate[1],
    };

    const transformString = buildTransformString(newTransform);
    element.setAttribute('transform', transformString);

    // Actualizar la transformaci贸n visual
    e.target.style.transform = e.drag.transform;

    if (onTransform) {
      onTransform({
        type: 'resize',
        element,
        transform: newTransform,
        width: e.width,
        height: e.height,
        event: e,
      });
    }

    console.log(' Resize:', {
      scale: { scaleX, scaleY },
      newTransform,
    });
  }, [buildTransformString, onTransform]);

  /**
   * Handler de fin de resize
   */
  const handleResizeEnd = useCallback((e) => {
    setIsResizing(false);
    const element = e.target;

    // Limpiar el style.transform
    element.style.transform = '';

    if (onTransformEnd) {
      const finalTransform = getElementTransform(element);
      onTransformEnd({
        type: 'resize',
        element,
        transform: finalTransform,
        event: e,
      });
    }

    initialTransformRef.current = null;

    console.log(' Resize End:', {
      element: element.id,
      finalTransform: getElementTransform(element),
    });
  }, [getElementTransform, onTransformEnd]);

  /**
   * Handler de inicio de rotate
   */
  const handleRotateStart = useCallback((e) => {
    setIsRotating(true);
    const element = e.target;
    initialTransformRef.current = getElementTransform(element);

    if (onTransformStart) {
      onTransformStart({ type: 'rotate', element, event: e });
    }

    console.log(' Rotate Start:', {
      element: element.id,
      initialTransform: initialTransformRef.current,
    });
  }, [getElementTransform, onTransformStart]);

  /**
   * Handler de rotate
   */
  const handleRotate = useCallback((e) => {
    const element = e.target;
    const initial = initialTransformRef.current;

    if (!initial) return;

    // Aplicar rotaci贸n
    const newTransform = {
      ...initial,
      rotation: e.rotate,
    };

    const transformString = buildTransformString(newTransform);
    element.setAttribute('transform', transformString);

    // Actualizar la transformaci贸n visual
    e.target.style.transform = e.drag.transform;

    if (onTransform) {
      onTransform({
        type: 'rotate',
        element,
        transform: newTransform,
        rotation: e.rotate,
        event: e,
      });
    }

    console.log(' Rotate:', {
      rotation: e.rotate,
      newTransform,
    });
  }, [buildTransformString, onTransform]);

  /**
   * Handler de fin de rotate
   */
  const handleRotateEnd = useCallback((e) => {
    setIsRotating(false);
    const element = e.target;

    // Limpiar el style.transform
    element.style.transform = '';

    if (onTransformEnd) {
      const finalTransform = getElementTransform(element);
      onTransformEnd({
        type: 'rotate',
        element,
        transform: finalTransform,
        event: e,
      });
    }

    initialTransformRef.current = null;

    console.log(' Rotate End:', {
      element: element.id,
      finalTransform: getElementTransform(element),
    });
  }, [getElementTransform, onTransformEnd]);

  return {
    // Estado
    isDragging,
    isResizing,
    isRotating,
    isTransforming: isDragging || isResizing || isRotating,

    // Drag handlers
    handleDragStart,
    handleDrag,
    handleDragEnd,

    // Resize handlers
    handleResizeStart,
    handleResize,
    handleResizeEnd,

    // Rotate handlers
    handleRotateStart,
    handleRotate,
    handleRotateEnd,

    // Utilidades
    getElementTransform,
    buildTransformString,
  };
}

export default useMoveable;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="CoordinateTransformer.html">CoordinateTransformer</a></li><li><a href="PathDataProcessor.html">PathDataProcessor</a></li><li><a href="SVGOptimizer.html">SVGOptimizer</a></li><li><a href="SVGWorld.html">SVGWorld</a></li></ul><h3>Global</h3><ul><li><a href="global.html#AdvancedTools">AdvancedTools</a></li><li><a href="global.html#BezierHandleEditor">BezierHandleEditor</a></li><li><a href="global.html#CodeView">CodeView</a></li><li><a href="global.html#Container">Container</a></li><li><a href="global.html#DEFAULT_CONFIG">DEFAULT_CONFIG</a></li><li><a href="global.html#FileLoadDemo">FileLoadDemo</a></li><li><a href="global.html#LanguageSelector">LanguageSelector</a></li><li><a href="global.html#MousePointerIcon">MousePointerIcon</a></li><li><a href="global.html#MoveableWrapper">MoveableWrapper</a></li><li><a href="global.html#NodeEditor">NodeEditor</a></li><li><a href="global.html#PathDebugger">PathDebugger</a></li><li><a href="global.html#PerformanceMetrics">PerformanceMetrics</a></li><li><a href="global.html#SVGHierarchy">SVGHierarchy</a></li><li><a href="global.html#SVGHistory">SVGHistory</a></li><li><a href="global.html#SVGMetadataEditor">SVGMetadataEditor</a></li><li><a href="global.html#SVGViewer">SVGViewer</a></li><li><a href="global.html#SettingsModal">SettingsModal</a></li><li><a href="global.html#SettingsView">SettingsView</a></li><li><a href="global.html#StylePanel">StylePanel</a></li><li><a href="global.html#TextInput">TextInput</a></li><li><a href="global.html#absoluteToRelative">absoluteToRelative</a></li><li><a href="global.html#addNodeToPath">addNodeToPath</a></li><li><a href="global.html#applyTransform">applyTransform</a></li><li><a href="global.html#buildPathFromNodes">buildPathFromNodes</a></li><li><a href="global.html#buildPathString">buildPathString</a></li><li><a href="global.html#checkLocalStorageAvailable">checkLocalStorageAvailable</a></li><li><a href="global.html#checkSessionStorageAvailable">checkSessionStorageAvailable</a></li><li><a href="global.html#circleToPath">circleToPath</a></li><li><a href="global.html#clearLocalStorage">clearLocalStorage</a></li><li><a href="global.html#clearSessionStorage">clearSessionStorage</a></li><li><a href="global.html#closePath">closePath</a></li><li><a href="global.html#countElements">countElements</a></li><li><a href="global.html#createCoordinateTransformer">createCoordinateTransformer</a></li><li><a href="global.html#createPathDataProcessor">createPathDataProcessor</a></li><li><a href="global.html#createSVGOptimizer">createSVGOptimizer</a></li><li><a href="global.html#createSVGWorld">createSVGWorld</a></li><li><a href="global.html#ellipseToPath">ellipseToPath</a></li><li><a href="global.html#formatNumber">formatNumber</a></li><li><a href="global.html#getElementBBox">getElementBBox</a></li><li><a href="global.html#getLocalStorageSize">getLocalStorageSize</a></li><li><a href="global.html#getSessionStorageSize">getSessionStorageSize</a></li><li><a href="global.html#getTransformedBBox">getTransformedBBox</a></li><li><a href="global.html#moveElement">moveElement</a></li><li><a href="global.html#optimizeSVG">optimizeSVG</a></li><li><a href="global.html#parsePathCommand">parsePathCommand</a></li><li><a href="global.html#parsePathNodes">parsePathNodes</a></li><li><a href="global.html#parseTransform">parseTransform</a></li><li><a href="global.html#pointToHorizontalLine">pointToHorizontalLine</a></li><li><a href="global.html#pointToLineTo">pointToLineTo</a></li><li><a href="global.html#pointToMoveTo">pointToMoveTo</a></li><li><a href="global.html#pointToSmoothQuadraticBezier">pointToSmoothQuadraticBezier</a></li><li><a href="global.html#pointToVerticalLine">pointToVerticalLine</a></li><li><a href="global.html#pointsToArc">pointsToArc</a></li><li><a href="global.html#pointsToCubicBezier">pointsToCubicBezier</a></li><li><a href="global.html#pointsToPath">pointsToPath</a></li><li><a href="global.html#pointsToQuadraticBezier">pointsToQuadraticBezier</a></li><li><a href="global.html#pointsToSmoothCubicBezier">pointsToSmoothCubicBezier</a></li><li><a href="global.html#rectToPath">rectToPath</a></li><li><a href="global.html#relativeToAbsolute">relativeToAbsolute</a></li><li><a href="global.html#removeNodeFromPath">removeNodeFromPath</a></li><li><a href="global.html#rotateElement">rotateElement</a></li><li><a href="global.html#scaleElement">scaleElement</a></li><li><a href="global.html#serializeTransform">serializeTransform</a></li><li><a href="global.html#simplifyPath">simplifyPath</a></li><li><a href="global.html#svgToScreenCoords">svgToScreenCoords</a></li><li><a href="global.html#updateNodeInPath">updateNodeInPath</a></li><li><a href="global.html#useCoordinateTransformer">useCoordinateTransformer</a></li><li><a href="global.html#useHistory">useHistory</a></li><li><a href="global.html#useLocalStorage">useLocalStorage</a></li><li><a href="global.html#useMoveable">useMoveable</a></li><li><a href="global.html#usePanzoom">usePanzoom</a></li><li><a href="global.html#usePathDataProcessor">usePathDataProcessor</a></li><li><a href="global.html#usePerformance">usePerformance</a></li><li><a href="global.html#useSVGParser">useSVGParser</a></li><li><a href="global.html#useSVGStorage">useSVGStorage</a></li><li><a href="global.html#useSVGWorld">useSVGWorld</a></li><li><a href="global.html#useSessionStorage">useSessionStorage</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.5</a> on Mon Nov 17 2025 13:59:29 GMT+1300 (New Zealand Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
