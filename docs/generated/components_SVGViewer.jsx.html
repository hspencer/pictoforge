<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: components/SVGViewer.jsx</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: components/SVGViewer.jsx</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import React, { useRef, useState, useEffect } from 'react';
import {
  ZoomIn,
  ZoomOut,
  RotateCcw,
  Maximize2,
  Undo,
  Redo
} from 'lucide-react';
import { Button } from '@/components/ui/button';
import { SelectArrowIcon, MousePointerIcon, PenToolIcon, ShareIcon } from './CustomIcons';
import MoveableWrapper from './MoveableWrapper';
import BezierHandleEditor from './BezierHandleEditor';
import NodeEditor from './NodeEditor';
import BoundingBox from './BoundingBox';
import useHistory from '../hooks/useHistory';
import usePerformance from '../hooks/usePerformance';
import usePanzoom from '../hooks/usePanzoom';
import useSVGWorld from '../hooks/useSVGWorld';
import useMoveable from '../hooks/useMoveable';
import PerformanceMetrics from './PerformanceMetrics';
import { rotateElement, scaleElement } from '../utils/svgManipulation';
// SVGWorld proporciona un sistema unificado de coordenadas y manipulaciÃ³n SVG

/**
 * Componente para visualizar y editar SVG
 */
export const SVGViewer = ({
  svgContent,
  selectedElement,
  onElementSelect,
  svgData,
  initialTool = 'select',
  onToolChange
}) => {
  const svgRef = useRef(null);
  const containerRef = useRef(null);
  const svgContainerRef = useRef(null); // Ref para el contenedor panzoom
  const overlayRef = useRef(null); // Ref para el SVG overlay
  const [tool, setToolInternal] = useState(initialTool);
  const [selectedSVGElement, setSelectedSVGElement] = useState(null);
  const [containerDimensions, setContainerDimensions] = useState({ width: 0, height: 0 });

  // Wrapper para setTool que tambiÃ©n llama al callback
  const setTool = (newTool) => {
    setToolInternal(newTool);
    onToolChange?.(newTool);
  };

  // Actualizar tool cuando cambia initialTool desde fuera
  useEffect(() => {
    setToolInternal(initialTool);
  }, [initialTool]);

  // Sincronizar selectedSVGElement cuando cambia selectedElement desde fuera (jerarquÃ­a)
  useEffect(() => {
    if (selectedElement &amp;&amp; svgRef.current) {
      const domElement = svgRef.current.querySelector(`#${selectedElement.id}`);
      if (domElement) {
        setSelectedSVGElement(domElement);
        console.log('ðŸ”„ Sincronizando selecciÃ³n desde jerarquÃ­a:', selectedElement.id);
      }
    } else if (!selectedElement) {
      setSelectedSVGElement(null);
    }
  }, [selectedElement]);

  // Sistema de zoom y pan con @panzoom/panzoom
  const {
    panzoomState,
    isReady: isPanzoomReady,
    zoomIn: panzoomZoomIn,
    zoomOut: panzoomZoomOut,
    reset: panzoomReset,
    center: panzoomCenter,
  } = usePanzoom({
    elementRef: svgContainerRef,
    panzoomOptions: {
      maxScale: 10,
      minScale: 0.1,
      step: 0.3,
      startScale: 1,
      canvas: true,
    },
  });

  // Sistema unificado de coordenadas y manipulaciÃ³n con SVGWorld
  const {
    isReady: isSVGWorldReady,
    screenToSVG,
    svgToScreen,
    screenDeltaToSVGDelta,
    getElementBBox,
    moveElement,
    world: svgWorld,
  } = useSVGWorld({
    svgRef: svgContainerRef,
    containerRef: containerRef,
    viewport: panzoomState,
  });

  // Sistema de manipulaciÃ³n con Moveable
  const {
    isDragging: isMoveableDragging,
    isResizing,
    isRotating,
    handleDragStart,
    handleDrag,
    handleDragEnd,
    handleResizeStart,
    handleResize,
    handleResizeEnd,
    handleRotateStart,
    handleRotate,
    handleRotateEnd,
  } = useMoveable({
    coordinateTransformer: svgWorld,
    onTransformStart: (data) => {
      console.log('ðŸŽ¯ Transform Start:', data.type);
    },
    onTransform: (data) => {
      // Actualizar en tiempo real si es necesario
    },
    onTransformEnd: (data) => {
      console.log('ðŸŽ¯ Transform End:', data.type, data.transform);
      // Guardar en historial
      if (svgContent) {
        const svg = svgContainerRef.current?.querySelector('svg');
        if (svg) {
          saveToHistory(svg.outerHTML);
        }
      }
    },
  });

  // Sistema de historial
  const {
    currentState: svgHistory,
    pushState: saveToHistory,
    undo: undoChange,
    redo: redoChange,
    canUndo,
    canRedo
  } = useHistory(svgContent);

  // Sistema de rendimiento
  const {
    complexity,
    optimizeSVG,
    debounce,
    throttle,
    metrics
  } = usePerformance(svgContent, {
    enableVirtualization: true,
    maxElements: 1000,
    debounceMs: 100
  });

  const [showMetrics, setShowMetrics] = useState(false);

  /**
   * Actualiza las dimensiones del contenedor para el overlay
   */
  useEffect(() => {
    const updateDimensions = () => {
      if (containerRef.current) {
        const rect = containerRef.current.getBoundingClientRect();
        setContainerDimensions({
          width: rect.width,
          height: rect.height
        });
      }
    };

    updateDimensions();
    window.addEventListener('resize', updateDimensions);
    return () => window.removeEventListener('resize', updateDimensions);
  }, []);

  // Auto-selecciÃ³n eliminada - el usuario debe seleccionar manualmente

  /**
   * Maneja la selecciÃ³n de elementos en el SVG
   */
  const handleElementClick = (event) => {
    event.stopPropagation();

    const target = event.target;
    const elementId = target.id || target.getAttribute('id');

    // Debug: Probar transformaciÃ³n de coordenadas
    const screenCoords = { x: event.clientX, y: event.clientY };
    const svgCoords = screenToSVG(screenCoords.x, screenCoords.y);

    console.log('ðŸ–±ï¸ Click en elemento:', {
      elementId,
      tagName: target.tagName,
      tool,
      screenCoords,
      svgCoords,
      panzoomState,
      svgWorldReady: isSVGWorldReady
    });

    if (tool === 'select') {
      // FLECHA NEGRA: Seleccionar elemento completo para mover/escalar/rotar

      // Bloquear selecciÃ³n del elemento raÃ­z "pictogram"
      if (elementId === 'pictogram' || target.tagName === 'svg') {
        console.log('ðŸš« No se puede seleccionar el elemento raÃ­z');
        return;
      }

      if (elementId &amp;&amp; svgData) {
        const element = findElementInData(elementId, svgData.root);
        console.log('âœ… Elemento encontrado en data:', element);
        if (element) {
          onElementSelect(element);
          setSelectedSVGElement(target);
          console.log('âœ… Elemento seleccionado para ediciÃ³n:', elementId);
        }
      } else {
        console.warn('âš ï¸ No se pudo seleccionar:', { elementId, hasSvgData: !!svgData });
      }
    } else if (tool === 'node') {
      // FLECHA BLANCA: Seleccionar path para editar nodos
      if (target.tagName === 'path') {
        const element = findElementInData(elementId, svgData.root);
        if (element) {
          onElementSelect(element);
          setSelectedSVGElement(target);
        }
      }
    } else if (tool === 'pen') {
      // HERRAMIENTA PLUMA: Similar a node pero para agregar/eliminar
      if (target.tagName === 'path') {
        setSelectedSVGElement(target);
      }
    }
  };

  /**
   * Maneja la manipulaciÃ³n de nodos individuales
   */
  const handleNodeManipulation = (event) => {
    const target = event.target;
    
    // Solo funciona en elementos path
    if (target.tagName === 'path') {
      const rect = target.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      
      console.log(`Manipulando nodo en: ${x}, ${y}`);
      // TODO: Implementar lÃ³gica de manipulaciÃ³n de nodos
      // - Detectar nodo mÃ¡s cercano
      // - Permitir arrastrar nodos
      // - Actualizar path data
    }
  };

  /**
   * Maneja la herramienta pluma para ediciÃ³n de nodos
   */
  const handlePenTool = (event) => {
    const target = event.target;
    
    if (target.tagName === 'path') {
      console.log('Herramienta pluma activada en path:', target.id);
      // TODO: Implementar herramienta pluma
      // - Agregar/eliminar nodos
      // - Cambiar tipo de nodo (smooth, corner, bezier)
      // - Mostrar handles de control
    }
  };

  /**
   * Busca un elemento en la estructura de datos por ID
   */
  const findElementInData = (id, element) => {
    if (element.id === id) return element;
    
    for (const child of element.children) {
      const found = findElementInData(id, child);
      if (found) return found;
    }
    
    return null;
  };

  /**
   * Resalta el elemento seleccionado
   */
  const highlightElement = (elementId) => {
    // Remover highlight anterior
    const prevHighlighted = svgRef.current?.querySelector('.highlighted');
    if (prevHighlighted) {
      prevHighlighted.classList.remove('highlighted');
    }

    // Agregar highlight al nuevo elemento por ID
    if (elementId &amp;&amp; svgRef.current) {
      const element = svgRef.current.querySelector(`#${elementId}`);
      if (element) {
        element.classList.add('highlighted');
      }
    }
  };

  /**
   * Maneja el zoom del SVG
   */
  const handleZoom = (direction) => {
    if (direction === 'in') {
      panzoomZoomIn();
    } else {
      panzoomZoomOut();
    }
  };

  /**
   * Resetea la vista del SVG
   */
  const resetView = () => {
    panzoomReset();
  };

  // Pan manual eliminado - ahora lo maneja @panzoom/panzoom automÃ¡ticamente

  /**
   * Genera un nombre Ãºnico con timestamp
   */
  const generateUniqueFilename = (prefix = 'pictogram', extension = 'svg') => {
    const now = new Date();
    const timestamp = now.toISOString()
      .replace(/[:.]/g, '-')
      .replace('T', '_')
      .slice(0, -5); // Remover milisegundos y Z
    return `${prefix}_${timestamp}.${extension}`;
  };

  /**
   * Descarga el SVG actual con nombre Ãºnico
   */
  const downloadSVG = () => {
    if (!svgContent) return;
    
    const blob = new Blob([svgContent], { type: 'image/svg+xml' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = generateUniqueFilename('pictoforge');
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };

  // Efecto para resaltar elemento seleccionado
  useEffect(() => {
    if (!svgRef.current) return;

    // Remover highlight anterior
    const prevHighlighted = svgRef.current.querySelector('.highlighted');
    if (prevHighlighted) {
      prevHighlighted.classList.remove('highlighted');
    }

    // Agregar highlight al nuevo elemento
    if (selectedElement?.id) {
      highlightElement(selectedElement.id);
    }
  }, [selectedElement]);

  if (!svgContent) {
    return (
      &lt;div className="h-full flex items-center justify-center bg-muted/20">
        &lt;div className="text-center text-muted-foreground">
          &lt;Maximize2 size={48} className="mx-auto mb-4 opacity-50" />
          &lt;p>No hay SVG cargado&lt;/p>
          &lt;p className="text-sm">Carga un archivo SVG para comenzar&lt;/p>
        &lt;/div>
      &lt;/div>
    );
  }

  return (
    &lt;div className="h-full flex flex-col bg-background">
      {/* Barra de herramientas */}
      &lt;div className="flex items-center justify-between p-2 border-b bg-muted/20">
        &lt;div className="flex items-center gap-1">
          &lt;Button
            variant={tool === 'select' ? 'default' : 'ghost'}
            size="sm"
            onClick={() => setTool('select')}
            title="Seleccionar y mover entidades (Flecha negra)"
          >
            &lt;SelectArrowIcon size={16} />
          &lt;/Button>
          &lt;Button
            variant={tool === 'node' ? 'default' : 'ghost'}
            size="sm"
            onClick={() => setTool('node')}
            title="Mover nodos (Flecha blanca)"
          >
            &lt;MousePointerIcon size={16} />
          &lt;/Button>
          &lt;Button
            variant={tool === 'pen' ? 'default' : 'ghost'}
            size="sm"
            onClick={() => setTool('pen')}
            title="Herramienta pluma - Editar nodos"
          >
            &lt;PenToolIcon size={16} />
          &lt;/Button>
        &lt;/div>

        &lt;div className="flex items-center gap-1">
          &lt;Button
            variant="ghost"
            size="sm"
            onClick={undoChange}
            disabled={!canUndo}
            title="Deshacer"
          >
            &lt;Undo size={16} />
          &lt;/Button>
          &lt;Button
            variant="ghost"
            size="sm"
            onClick={redoChange}
            disabled={!canRedo}
            title="Rehacer"
          >
            &lt;Redo size={16} />
          &lt;/Button>
          &lt;div className="w-px h-4 bg-border mx-1" />
          &lt;Button
            variant="ghost"
            size="sm"
            onClick={() => handleZoom('out')}
            title="Alejar"
          >
            &lt;ZoomOut size={16} />
          &lt;/Button>
          &lt;span className="text-sm text-muted-foreground min-w-[4rem] text-center">
            {Math.round(panzoomState.scale * 100)}%
          &lt;/span>
          &lt;Button
            variant="ghost"
            size="sm"
            onClick={() => handleZoom('in')}
            title="Acercar"
          >
            &lt;ZoomIn size={16} />
          &lt;/Button>
          &lt;Button
            variant="ghost"
            size="sm"
            onClick={resetView}
            title="Resetear vista"
          >
            &lt;RotateCcw size={16} />
          &lt;/Button>
          &lt;Button
            variant="ghost"
            size="sm"
            onClick={downloadSVG}
            title="Exportar SVG"
          >
            &lt;ShareIcon size={16} />
          &lt;/Button>
          &lt;div className="w-px h-4 bg-border mx-1" />
          &lt;Button
            variant="ghost"
            size="sm"
            onClick={() => setShowMetrics(!showMetrics)}
            title="Mostrar mÃ©tricas de rendimiento"
            className={showMetrics ? 'bg-blue-100' : ''}
          >
            ðŸ“Š
          &lt;/Button>
        &lt;/div>
      &lt;/div>

      {/* Ãrea de visualizaciÃ³n */}
      &lt;div
        ref={containerRef}
        className={`flex-1 overflow-hidden relative bg-gradient-to-br from-muted/10 to-muted/30
          ${tool === 'node' || isMoveableDragging ? 'cursor-move' :
            tool === 'pen' ? 'cursor-crosshair' :
            'cursor-default'}`}
      >
        {svgContent ? (
          &lt;>
            {/* SVG Content - Panzoom aplica transformaciÃ³n automÃ¡ticamente */}
            &lt;div
              ref={svgContainerRef}
              className="svg-panzoom-container"
              style={{
                position: 'relative',
                transformOrigin: '0 0',
                width: '100%',
                height: '100%',
              }}
            >
              &lt;div
                ref={svgRef}
                className="svg-container"
                onClick={handleElementClick}
              >
                &lt;div dangerouslySetInnerHTML={{ __html: svgContent }} />
              &lt;/div>
            &lt;/div>

            {/* Overlay SVG - MISMO sistema de coordenadas que el SVG original */}
            {selectedSVGElement &amp;&amp; (() => {
              const svg = svgRef.current?.querySelector('svg');
              if (!svg) return null;

              const viewBox = svg.viewBox.baseVal;
              const bbox = selectedSVGElement.getBBox();

              console.log('ðŸ“¦ BoundingBox en SVG coords:', { bbox, viewBox: `${viewBox.x} ${viewBox.y} ${viewBox.width} ${viewBox.height}` });

              return (
                &lt;div
                  className="absolute inset-0 flex items-center justify-center pointer-events-none"
                  style={{
                    transform: `translate(${panzoomState.x}px, ${panzoomState.y}px) scale(${panzoomState.scale})`,
                    transformOrigin: 'center'
                  }}
                >
                  &lt;svg
                    style={{
                      width: svg.clientWidth,
                      height: svg.clientHeight,
                      pointerEvents: 'none'
                    }}
                    viewBox={`${viewBox.x} ${viewBox.y} ${viewBox.width} ${viewBox.height}`}
                  >
                    {/* BoundingBox simple en coordenadas SVG */}
                    &lt;rect
                      x={bbox.x}
                      y={bbox.y}
                      width={bbox.width}
                      height={bbox.height}
                      className="svg-bounding-box-simple"
                      pointerEvents="all"
                      onMouseDown={(e) => {
                        e.stopPropagation();
                        e.preventDefault();

                        const startX = e.clientX;
                        const startY = e.clientY;

                        // Obtener transform actual
                        const currentTransform = selectedSVGElement.getAttribute('transform') || '';
                        const translateMatch = currentTransform.match(/translate\(([^,]+),\s*([^)]+)\)/);
                        let currentTx = translateMatch ? parseFloat(translateMatch[1]) : 0;
                        let currentTy = translateMatch ? parseFloat(translateMatch[2]) : 0;

                        const handleMouseMove = (e) => {
                          const deltaX = e.clientX - startX;
                          const deltaY = e.clientY - startY;

                          // Convertir delta de pÃ­xeles a unidades SVG
                          const svgDeltaX = deltaX / panzoomState.scale;
                          const svgDeltaY = deltaY / panzoomState.scale;

                          // Aplicar nuevo transform
                          const newTx = currentTx + svgDeltaX;
                          const newTy = currentTy + svgDeltaY;

                          selectedSVGElement.setAttribute('transform', `translate(${newTx}, ${newTy})`);

                          // Forzar re-render del BoundingBox
                          setSelectedSVGElement(selectedSVGElement);
                        };

                        const handleMouseUp = () => {
                          document.removeEventListener('mousemove', handleMouseMove);
                          document.removeEventListener('mouseup', handleMouseUp);
                          console.log('âœ… Drag completado');
                        };

                        document.addEventListener('mousemove', handleMouseMove);
                        document.addEventListener('mouseup', handleMouseUp);
                      }}
                    />

                    {/* Handles en las esquinas - TAMAÃ‘O FIJO EN PÃXELES */}
                    {[
                      { x: bbox.x, y: bbox.y, cursorClass: 'cursor-nw-resize' },
                      { x: bbox.x + bbox.width, y: bbox.y, cursorClass: 'cursor-ne-resize' },
                      { x: bbox.x + bbox.width, y: bbox.y + bbox.height, cursorClass: 'cursor-se-resize' },
                      { x: bbox.x, y: bbox.y + bbox.height, cursorClass: 'cursor-sw-resize' }
                    ].map((pos, i) => (
                      &lt;rect
                        key={i}
                        x={pos.x - 0.8}
                        y={pos.y - 0.8}
                        width={1.6}
                        height={1.6}
                        className={`svg-resize-handle-simple ${pos.cursorClass}`}
                        pointerEvents="all"
                        onMouseDown={(e) => {
                          console.log('ðŸ–±ï¸ MouseDown en handle', i);
                          e.stopPropagation();
                        }}
                      />
                    ))}

                    {/* Manipulador de rotaciÃ³n - cÃ­rculo arriba del centro */}
                    &lt;line
                      x1={bbox.x + bbox.width / 2}
                      y1={bbox.y}
                      x2={bbox.x + bbox.width / 2}
                      y2={bbox.y - 5}
                      className="svg-rotation-line"
                      pointerEvents="none"
                    />
                    &lt;circle
                      cx={bbox.x + bbox.width / 2}
                      cy={bbox.y - 5}
                      r={1}
                      className="svg-rotation-handle"
                      pointerEvents="all"
                      onMouseDown={(e) => {
                        console.log('ðŸ”„ MouseDown en rotaciÃ³n');
                        e.stopPropagation();
                      }}
                    />
                  &lt;/svg>
                &lt;/div>
              );
            })()}

            {/* Overlay SVG viejo - mantener para NodeEditor */}
            &lt;svg
              ref={overlayRef}
              className="absolute inset-0 w-full h-full pointer-events-none"
              viewBox={`0 0 ${containerDimensions.width || 800} ${containerDimensions.height || 600}`}
              style={{ zIndex: 10, display: 'none' }}
            >
              &lt;BoundingBox
                  element={null}
                  onResize={(handleId, deltaX, deltaY) => {
                    if (!selectedSVGElement) return;
                    
                    // Guardar estado antes del cambio
                    saveToHistory(svgRef.current?.innerHTML);
                    
                    const bbox = getElementBBox(selectedSVGElement);
                    if (!bbox) return;
                    
                    // Calcular nueva escala basada en el handle
                    let scaleX = 1, scaleY = 1;
                    
                    switch (handleId) {
                      case 'se': // esquina inferior derecha
                        scaleX = (bbox.width + deltaX) / bbox.width;
                        scaleY = (bbox.height + deltaY) / bbox.height;
                        break;
                      case 'e': // lado derecho
                        scaleX = (bbox.width + deltaX) / bbox.width;
                        break;
                      case 's': // lado inferior
                        scaleY = (bbox.height + deltaY) / bbox.height;
                        break;
                      case 'nw': // esquina superior izquierda
                        scaleX = (bbox.width - deltaX) / bbox.width;
                        scaleY = (bbox.height - deltaY) / bbox.height;
                        break;
                    }
                    
                    scaleElement(selectedSVGElement, scaleX, scaleY, bbox.x, bbox.y);
                  }}
                  onMove={(deltaX, deltaY) => {
                    if (!selectedSVGElement) return;
                    moveElement(selectedSVGElement, deltaX, deltaY);
                  }}
                  onRotate={(angle, centerX, centerY) => {
                    if (!selectedSVGElement) return;

                    // Guardar estado antes del cambio (solo la primera vez)
                    if (!isMoveableDragging) {
                      saveToHistory(svgRef.current?.innerHTML);
                    }

                    rotateElement(selectedSVGElement, angle, centerX, centerY);
                  }}
                />
                
                &lt;NodeEditor
                  element={selectedSVGElement}
                  tool={tool}
                  visible={(tool === 'node' || tool === 'pen') &amp;&amp; selectedSVGElement}
                  viewport={{ zoom: panzoomState.scale, pan: { x: panzoomState.x, y: panzoomState.y } }}
                  containerRef={containerRef}
                  onNodeChange={(oldNode, newNode) => {
                    if (!selectedSVGElement) return;
                    
                    // Guardar estado antes del cambio
                    saveToHistory(svgRef.current?.innerHTML);
                    
                    // Actualizar el nodo en el path
                    updateNodeInPath(selectedSVGElement, oldNode.index, newNode);
                  }}
                  onNodeAdd={(position) => {
                    if (!selectedSVGElement) return;
                    
                    // Guardar estado antes del cambio
                    saveToHistory(svgRef.current?.innerHTML);
                    
                    // Agregar nuevo nodo al path
                    addNodeToPath(selectedSVGElement, position);
                  }}
                  onNodeRemove={(node) => {
                    if (!selectedSVGElement) return;
                    
                    // Guardar estado antes del cambio
                    saveToHistory(svgRef.current?.innerHTML);
                    
                    // Eliminar nodo del path
                    removeNodeFromPath(selectedSVGElement, node.index);
                  }}
                />
              &lt;/svg>

            {/* MÃ©tricas de rendimiento */}
            &lt;PerformanceMetrics
              metrics={metrics}
              visible={showMetrics}
            />
          &lt;/>
        ) : (
          &lt;div className="flex-1 flex items-center justify-center text-gray-500">
            &lt;div className="text-center">
              &lt;div className="text-lg mb-2">No hay SVG cargado&lt;/div>
              &lt;div className="text-sm">Carga un archivo SVG para comenzar&lt;/div>
            &lt;/div>
          &lt;/div>
        )}
      &lt;/div>
    &lt;/div>
  );
};

export default SVGViewer;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="CoordinateTransformer.html">CoordinateTransformer</a></li><li><a href="PathDataProcessor.html">PathDataProcessor</a></li><li><a href="SVGOptimizer.html">SVGOptimizer</a></li><li><a href="SVGWorld.html">SVGWorld</a></li></ul><h3>Global</h3><ul><li><a href="global.html#AdvancedTools">AdvancedTools</a></li><li><a href="global.html#BezierHandleEditor">BezierHandleEditor</a></li><li><a href="global.html#CodeView">CodeView</a></li><li><a href="global.html#Container">Container</a></li><li><a href="global.html#DEFAULT_CONFIG">DEFAULT_CONFIG</a></li><li><a href="global.html#FileLoadDemo">FileLoadDemo</a></li><li><a href="global.html#LanguageSelector">LanguageSelector</a></li><li><a href="global.html#MousePointerIcon">MousePointerIcon</a></li><li><a href="global.html#MoveableWrapper">MoveableWrapper</a></li><li><a href="global.html#NodeEditor">NodeEditor</a></li><li><a href="global.html#PathDebugger">PathDebugger</a></li><li><a href="global.html#PerformanceMetrics">PerformanceMetrics</a></li><li><a href="global.html#SVGHierarchy">SVGHierarchy</a></li><li><a href="global.html#SVGHistory">SVGHistory</a></li><li><a href="global.html#SVGMetadataEditor">SVGMetadataEditor</a></li><li><a href="global.html#SVGViewer">SVGViewer</a></li><li><a href="global.html#SettingsModal">SettingsModal</a></li><li><a href="global.html#SettingsView">SettingsView</a></li><li><a href="global.html#StylePanel">StylePanel</a></li><li><a href="global.html#TextInput">TextInput</a></li><li><a href="global.html#absoluteToRelative">absoluteToRelative</a></li><li><a href="global.html#addNodeToPath">addNodeToPath</a></li><li><a href="global.html#applyTransform">applyTransform</a></li><li><a href="global.html#buildPathFromNodes">buildPathFromNodes</a></li><li><a href="global.html#buildPathString">buildPathString</a></li><li><a href="global.html#checkLocalStorageAvailable">checkLocalStorageAvailable</a></li><li><a href="global.html#checkSessionStorageAvailable">checkSessionStorageAvailable</a></li><li><a href="global.html#circleToPath">circleToPath</a></li><li><a href="global.html#clearLocalStorage">clearLocalStorage</a></li><li><a href="global.html#clearSessionStorage">clearSessionStorage</a></li><li><a href="global.html#closePath">closePath</a></li><li><a href="global.html#countElements">countElements</a></li><li><a href="global.html#createCoordinateTransformer">createCoordinateTransformer</a></li><li><a href="global.html#createPathDataProcessor">createPathDataProcessor</a></li><li><a href="global.html#createSVGOptimizer">createSVGOptimizer</a></li><li><a href="global.html#createSVGWorld">createSVGWorld</a></li><li><a href="global.html#ellipseToPath">ellipseToPath</a></li><li><a href="global.html#formatNumber">formatNumber</a></li><li><a href="global.html#getElementBBox">getElementBBox</a></li><li><a href="global.html#getLocalStorageSize">getLocalStorageSize</a></li><li><a href="global.html#getSessionStorageSize">getSessionStorageSize</a></li><li><a href="global.html#getTransformedBBox">getTransformedBBox</a></li><li><a href="global.html#moveElement">moveElement</a></li><li><a href="global.html#optimizeSVG">optimizeSVG</a></li><li><a href="global.html#parsePathCommand">parsePathCommand</a></li><li><a href="global.html#parsePathNodes">parsePathNodes</a></li><li><a href="global.html#parseTransform">parseTransform</a></li><li><a href="global.html#pointToHorizontalLine">pointToHorizontalLine</a></li><li><a href="global.html#pointToLineTo">pointToLineTo</a></li><li><a href="global.html#pointToMoveTo">pointToMoveTo</a></li><li><a href="global.html#pointToSmoothQuadraticBezier">pointToSmoothQuadraticBezier</a></li><li><a href="global.html#pointToVerticalLine">pointToVerticalLine</a></li><li><a href="global.html#pointsToArc">pointsToArc</a></li><li><a href="global.html#pointsToCubicBezier">pointsToCubicBezier</a></li><li><a href="global.html#pointsToPath">pointsToPath</a></li><li><a href="global.html#pointsToQuadraticBezier">pointsToQuadraticBezier</a></li><li><a href="global.html#pointsToSmoothCubicBezier">pointsToSmoothCubicBezier</a></li><li><a href="global.html#rectToPath">rectToPath</a></li><li><a href="global.html#relativeToAbsolute">relativeToAbsolute</a></li><li><a href="global.html#removeNodeFromPath">removeNodeFromPath</a></li><li><a href="global.html#rotateElement">rotateElement</a></li><li><a href="global.html#scaleElement">scaleElement</a></li><li><a href="global.html#serializeTransform">serializeTransform</a></li><li><a href="global.html#simplifyPath">simplifyPath</a></li><li><a href="global.html#svgToScreenCoords">svgToScreenCoords</a></li><li><a href="global.html#updateNodeInPath">updateNodeInPath</a></li><li><a href="global.html#useCoordinateTransformer">useCoordinateTransformer</a></li><li><a href="global.html#useHistory">useHistory</a></li><li><a href="global.html#useLocalStorage">useLocalStorage</a></li><li><a href="global.html#useMoveable">useMoveable</a></li><li><a href="global.html#usePanzoom">usePanzoom</a></li><li><a href="global.html#usePathDataProcessor">usePathDataProcessor</a></li><li><a href="global.html#usePerformance">usePerformance</a></li><li><a href="global.html#useSVGParser">useSVGParser</a></li><li><a href="global.html#useSVGStorage">useSVGStorage</a></li><li><a href="global.html#useSVGWorld">useSVGWorld</a></li><li><a href="global.html#useSessionStorage">useSessionStorage</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.5</a> on Mon Nov 17 2025 13:59:29 GMT+1300 (New Zealand Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
