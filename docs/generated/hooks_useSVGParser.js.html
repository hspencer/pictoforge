<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: hooks/useSVGParser.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: hooks/useSVGParser.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { useState, useCallback } from 'react';

/**
 * Hook personalizado para parsear SVG y manejar la estructura de datos
 * Extrae la jerarquía de elementos, estilos y metadatos del SVG
 */
export const useSVGParser = () => {
  const [svgData, setSvgData] = useState(null);
  const [selectedElement, setSelectedElement] = useState(null);
  const [svgContent, setSvgContent] = useState('');

  // Elementos técnicos que no se deben mostrar en la jerarquía visual
  const TECHNICAL_ELEMENTS = new Set([
    'defs',
    'style',
    'metadata',
    'title',
    'desc',
    'script',
    'clipPath',
    'mask',
    'linearGradient',
    'radialGradient',
    'pattern',
    'filter',
    'marker'
  ]);

  /**
   * Verifica si un elemento debe incluirse en la jerarquía visual
   */
  const shouldIncludeElement = useCallback((tagName) => {
    return !TECHNICAL_ELEMENTS.has(tagName.toLowerCase());
  }, []);

  /**
   * Parsea un elemento SVG y extrae su información
   */
  const parseElement = useCallback((element, parent = null) => {
    const elementData = {
      id: element.id || `element_${Math.random().toString(36).substring(2, 11)}`,
      tagName: element.tagName.toLowerCase(),
      className: element.className.baseVal || element.getAttribute('class') || '',
      attributes: {},
      children: [],
      parent: parent,
      element: element // Referencia al elemento DOM real
    };

    // Extraer todos los atributos
    Array.from(element.attributes).forEach(attr => {
      if (attr.name !== 'id' &amp;&amp; attr.name !== 'class') {
        elementData.attributes[attr.name] = attr.value;
      }
    });

    // Parsear elementos hijos recursivamente (solo elementos visuales)
    Array.from(element.children).forEach(child => {
      if (child.tagName &amp;&amp; shouldIncludeElement(child.tagName)) {
        const childData = parseElement(child, elementData);
        elementData.children.push(childData);
      }
    });

    return elementData;
  }, [shouldIncludeElement]);

  /**
   * Extrae los estilos CSS definidos en el SVG
   */
  const extractStyles = (svgElement) => {
    const styles = {};
    const styleElements = svgElement.querySelectorAll('style');

    styleElements.forEach(styleEl => {
      const cssText = styleEl.textContent;
      // Parsear reglas CSS básicas
      const rules = cssText.match(/\.[^{]+\{[^}]+\}/g) || [];

      rules.forEach(rule => {
        const match = rule.match(/\.([^{]+)\{([^}]+)\}/);
        if (match) {
          const className = match[1].trim();
          const properties = match[2].trim();
          styles[className] = properties;
        }
      });
    });

    return styles;
  };

  /**
   * Parsea el contenido SVG completo
   */
  const parseSVG = useCallback((svgString) => {
    try {
      // Validar que el string no esté vacío
      if (!svgString || typeof svgString !== 'string') {
        throw new Error('El contenido del SVG está vacío o no es válido');
      }

      // Limpiar el contenido (eliminar BOM, espacios al inicio/final, etc.)
      const cleanedSVG = svgString.trim().replace(/^\uFEFF/, '');

      // Crear un parser DOM temporal - intentar parsear sin validación previa
      const parser = new DOMParser();
      const doc = parser.parseFromString(cleanedSVG, 'image/svg+xml');

      // Verificar errores críticos de parseo XML
      const parserError = doc.querySelector('parsererror');
      if (parserError) {
        const errorText = parserError.textContent || 'Error de sintaxis XML';
        console.warn('⚠️ Parser error details:', errorText);
        // No lanzar error, intentar recuperar el SVG de todas formas
      }

      // Buscar el elemento SVG de múltiples formas
      let svgElement = doc.querySelector('svg');

      // Si no se encuentra, intentar como primer hijo del documento
      if (!svgElement &amp;&amp; doc.documentElement &amp;&amp; doc.documentElement.tagName === 'svg') {
        svgElement = doc.documentElement;
      }

      // Si aún no se encuentra, intentar buscar en el HTML
      if (!svgElement) {
        const htmlDoc = parser.parseFromString(cleanedSVG, 'text/html');
        svgElement = htmlDoc.querySelector('svg');
      }

      if (!svgElement) {
        throw new Error('No se encontró elemento &lt;svg> en el archivo. Verifica que sea un archivo SVG válido.');
      }

      console.log('✓ Elemento SVG encontrado:', svgElement.tagName);

      // Extraer información del SVG raíz
      const rootData = parseElement(svgElement);

      // Extraer estilos
      const styles = extractStyles(svgElement);

      // Extraer viewBox y dimensiones con valores por defecto más inteligentes
      const viewBox = svgElement.getAttribute('viewBox') ||
                      svgElement.getAttribute('viewbox') ||
                      `0 0 ${svgElement.getAttribute('width') || 100} ${svgElement.getAttribute('height') || 100}`;
      const width = svgElement.getAttribute('width') ||
                    svgElement.getAttribute('viewBox')?.split(' ')[2] ||
                    '100';
      const height = svgElement.getAttribute('height') ||
                     svgElement.getAttribute('viewBox')?.split(' ')[3] ||
                     '100';

      const parsedData = {
        root: rootData,
        styles: styles,
        viewBox: viewBox,
        width: width,
        height: height,
        originalSVG: cleanedSVG,
        elementCount: rootData.children.length
      };

      console.log('✓ SVG parseado exitosamente:', {
        elementos: parsedData.elementCount,
        dimensiones: `${width}x${height}`,
        viewBox: viewBox
      });

      setSvgData(parsedData);
      setSvgContent(cleanedSVG);
      return { success: true, data: parsedData };

    } catch (error) {
      console.error('✗ Error al parsear SVG:', error);
      setSvgData(null);
      setSvgContent('');
      return { success: false, error: error.message };
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  /**
   * Carga un archivo SVG desde una URL o string
   */
  const loadSVG = useCallback(async (source) => {
    try {
      let svgString;

      if (typeof source === 'string' &amp;&amp; source.startsWith('&lt;svg')) {
        // Es contenido SVG directo
        svgString = source;
      } else if (typeof source === 'string') {
        // Es una URL, cargar el archivo
        const response = await fetch(source);
        svgString = await response.text();
      } else if (source instanceof File) {
        // Es un archivo subido
        svgString = await source.text();
      } else {
        throw new Error('Tipo de fuente no soportado');
      }

      return parseSVG(svgString);
    } catch (error) {
      console.error('Error al cargar SVG:', error);
      return null;
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  /**
   * Busca un elemento por ID en la estructura parseada
   */
  const findElementById = useCallback((id, element = null) => {
    if (!svgData) return null;
    
    const searchElement = element || svgData.root;
    
    if (searchElement.id === id) {
      return searchElement;
    }

    for (const child of searchElement.children) {
      const found = findElementById(id, child);
      if (found) return found;
    }

    return null;
  }, [svgData]);

  /**
   * Obtiene todos los elementos de un tipo específico
   */
  const getElementsByType = useCallback((tagName) => {
    if (!svgData) return [];
    
    const elements = [];
    
    const traverse = (element) => {
      if (element.tagName === tagName) {
        elements.push(element);
      }
      element.children.forEach(traverse);
    };

    traverse(svgData.root);
    return elements;
  }, [svgData]);

  /**
   * Obtiene la ruta completa de un elemento (breadcrumb)
   */
  const getElementPath = useCallback((elementId) => {
    const element = findElementById(elementId);
    if (!element) return [];

    const path = [];
    let current = element;
    
    while (current) {
      path.unshift({
        id: current.id,
        tagName: current.tagName,
        className: current.className
      });
      current = current.parent;
    }

    return path;
  }, [findElementById]);

  return {
    // Estado
    svgData,
    selectedElement,
    svgContent,
    
    // Acciones
    parseSVG,
    loadSVG,
    setSelectedElement,
    
    // Utilidades
    findElementById,
    getElementsByType,
    getElementPath
  };
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="CoordinateTransformer.html">CoordinateTransformer</a></li><li><a href="PathDataProcessor.html">PathDataProcessor</a></li><li><a href="SVGOptimizer.html">SVGOptimizer</a></li><li><a href="SVGWorld.html">SVGWorld</a></li></ul><h3>Global</h3><ul><li><a href="global.html#AdvancedTools">AdvancedTools</a></li><li><a href="global.html#BezierHandleEditor">BezierHandleEditor</a></li><li><a href="global.html#CodeView">CodeView</a></li><li><a href="global.html#Container">Container</a></li><li><a href="global.html#DEFAULT_CONFIG">DEFAULT_CONFIG</a></li><li><a href="global.html#FileLoadDemo">FileLoadDemo</a></li><li><a href="global.html#LanguageSelector">LanguageSelector</a></li><li><a href="global.html#MousePointerIcon">MousePointerIcon</a></li><li><a href="global.html#MoveableWrapper">MoveableWrapper</a></li><li><a href="global.html#NodeEditor">NodeEditor</a></li><li><a href="global.html#PathDebugger">PathDebugger</a></li><li><a href="global.html#PerformanceMetrics">PerformanceMetrics</a></li><li><a href="global.html#SVGHierarchy">SVGHierarchy</a></li><li><a href="global.html#SVGHistory">SVGHistory</a></li><li><a href="global.html#SVGMetadataEditor">SVGMetadataEditor</a></li><li><a href="global.html#SVGViewer">SVGViewer</a></li><li><a href="global.html#SettingsModal">SettingsModal</a></li><li><a href="global.html#SettingsView">SettingsView</a></li><li><a href="global.html#StylePanel">StylePanel</a></li><li><a href="global.html#TextInput">TextInput</a></li><li><a href="global.html#absoluteToRelative">absoluteToRelative</a></li><li><a href="global.html#addNodeToPath">addNodeToPath</a></li><li><a href="global.html#applyTransform">applyTransform</a></li><li><a href="global.html#buildPathFromNodes">buildPathFromNodes</a></li><li><a href="global.html#buildPathString">buildPathString</a></li><li><a href="global.html#checkLocalStorageAvailable">checkLocalStorageAvailable</a></li><li><a href="global.html#checkSessionStorageAvailable">checkSessionStorageAvailable</a></li><li><a href="global.html#circleToPath">circleToPath</a></li><li><a href="global.html#clearLocalStorage">clearLocalStorage</a></li><li><a href="global.html#clearSessionStorage">clearSessionStorage</a></li><li><a href="global.html#closePath">closePath</a></li><li><a href="global.html#countElements">countElements</a></li><li><a href="global.html#createCoordinateTransformer">createCoordinateTransformer</a></li><li><a href="global.html#createPathDataProcessor">createPathDataProcessor</a></li><li><a href="global.html#createSVGOptimizer">createSVGOptimizer</a></li><li><a href="global.html#createSVGWorld">createSVGWorld</a></li><li><a href="global.html#ellipseToPath">ellipseToPath</a></li><li><a href="global.html#formatNumber">formatNumber</a></li><li><a href="global.html#getElementBBox">getElementBBox</a></li><li><a href="global.html#getLocalStorageSize">getLocalStorageSize</a></li><li><a href="global.html#getSessionStorageSize">getSessionStorageSize</a></li><li><a href="global.html#getTransformedBBox">getTransformedBBox</a></li><li><a href="global.html#moveElement">moveElement</a></li><li><a href="global.html#optimizeSVG">optimizeSVG</a></li><li><a href="global.html#parsePathCommand">parsePathCommand</a></li><li><a href="global.html#parsePathNodes">parsePathNodes</a></li><li><a href="global.html#parseTransform">parseTransform</a></li><li><a href="global.html#pointToHorizontalLine">pointToHorizontalLine</a></li><li><a href="global.html#pointToLineTo">pointToLineTo</a></li><li><a href="global.html#pointToMoveTo">pointToMoveTo</a></li><li><a href="global.html#pointToSmoothQuadraticBezier">pointToSmoothQuadraticBezier</a></li><li><a href="global.html#pointToVerticalLine">pointToVerticalLine</a></li><li><a href="global.html#pointsToArc">pointsToArc</a></li><li><a href="global.html#pointsToCubicBezier">pointsToCubicBezier</a></li><li><a href="global.html#pointsToPath">pointsToPath</a></li><li><a href="global.html#pointsToQuadraticBezier">pointsToQuadraticBezier</a></li><li><a href="global.html#pointsToSmoothCubicBezier">pointsToSmoothCubicBezier</a></li><li><a href="global.html#rectToPath">rectToPath</a></li><li><a href="global.html#relativeToAbsolute">relativeToAbsolute</a></li><li><a href="global.html#removeNodeFromPath">removeNodeFromPath</a></li><li><a href="global.html#rotateElement">rotateElement</a></li><li><a href="global.html#scaleElement">scaleElement</a></li><li><a href="global.html#serializeTransform">serializeTransform</a></li><li><a href="global.html#simplifyPath">simplifyPath</a></li><li><a href="global.html#svgToScreenCoords">svgToScreenCoords</a></li><li><a href="global.html#updateNodeInPath">updateNodeInPath</a></li><li><a href="global.html#useCoordinateTransformer">useCoordinateTransformer</a></li><li><a href="global.html#useHistory">useHistory</a></li><li><a href="global.html#useLocalStorage">useLocalStorage</a></li><li><a href="global.html#useMoveable">useMoveable</a></li><li><a href="global.html#usePanzoom">usePanzoom</a></li><li><a href="global.html#usePathDataProcessor">usePathDataProcessor</a></li><li><a href="global.html#usePerformance">usePerformance</a></li><li><a href="global.html#useSVGParser">useSVGParser</a></li><li><a href="global.html#useSVGStorage">useSVGStorage</a></li><li><a href="global.html#useSVGWorld">useSVGWorld</a></li><li><a href="global.html#useSessionStorage">useSessionStorage</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.5</a> on Mon Nov 17 2025 13:59:29 GMT+1300 (New Zealand Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
